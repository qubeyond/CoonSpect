 Так, коллеги, вопрос на самом деле меня интересный, это на чём вы остановились на прошлой лекции? На Маркен-Свип? Окей, ну да, сейчас как бы... Ну и вот, соответственно, на Маркен-Свип  То есть эта идея, с одной стороны, довольно простая, что мы берем все, так называемые, корневые объекты, то есть корневые объекты, что такое в разных языках, это разные понятия. Ну, в джаве, в первом приближении, это все именованы переменные, плюс еще какие-то скрытые отраски,  переменной в метрах самого JWM. То есть, когда вы будете проходить джавовские потоки, то вы обнаружите, что даже если вы не сохраните ни одной ссылки на объект потока, пока этот поток исполняется, он никуда не едется. И тем не менее, все эти объекты, Java их, точнее, даже, наверное, не сама Java, а garbage collector,  он по ним проходит и идет в глубину и помечает все объекты. Когда он находит пустую ссылку или уже помеченный объект, он дальше по этой редке не идет. Тем не менее, просмотр в глубину. Ну и на самом деле, главное еще забыл сказать, что перед тем, как делать этот просмотр, надо сделать так называемую остановку мира.  То есть, поскольку я упомянул потоки, то их надо все остановить. В принципе, понятно почему. Потому что если мы объект пометили, а потом его поменяют, то мы можем потерять какие-то живые объекты. И поэтому идет остановка мира. Потом, когда мы все объекты просмотрели, мы мир отпускаем.  и в фоновом режиме собираем, собственно, мусор. То есть проходим все объекты, которые они пометили. В Java у них зовут финализаторы, и вы их... Все они, так сказать, опять же, по русскоязычной разработке JVM, разработчики, они употребляют такое забавное слово RIP. Да? Ну, глагол RIP по-английски проходили.  Гремлика. Знакомое понятие. Английские тексты Рептуни читают, да? Мрачный жнец. Смерть. Да, Репта просто жать. Мрачный жнец. Ну, вот, тем не менее, да, их, так сказать, репут. Ну, причем, действительно, с ИП еще, действительно, глаголы не употребляют для обозначения того, что с этими агентами происходит  Ну и вот, на самом деле, просмотр ссылок, он, во-первых, это штука дорогая. То есть, как я уже говорил, надо останавливать мир, останавливать все нити. Во-вторых, чтобы его делать, тоже так же, как с подсчетом ссылок, нужно то, что в Java называются RTTI, Run-Type Information.  То есть нам надо знать, что какое поле каждого объекта является ссылкой. И на что эта ссылка указывает. В Django мы это знаем. В C++, например, или тем более в C, мы этого не знаем. Поэтому про RSI построить такое невозможно. Тем не менее, почти все языки, с которыми вы имеете дело, они используют именно такой сборщик мусора. Забавное исключение – это Python.  в котором делается вещь, которая, в общем-то, у меня в книжке написано, что ее никто не делал. Оказывается, в Питоне ее сделали гибридный сборщик мусора, который в основном собирает мусор под счетом ссылок, но когда ему кажется, что он собрал, что маловато, он запускает так называемый циклический сборщик, который вот и есть марконслит с чистым. Тем не менее, просмотр ссылок  Ну и вот первая проблема, о которой я говорил, это дорого. Вторая проблема, точнее это никак не проблема, но ее пытаются решать тем, что на самом деле стоимость просмотра ссылок, она примерно, не примерно, а точно пропорциональна количеству живых объектов. Поэтому если у вас нет у птички памяти, то у вас количество живых объектов примерно постоянное. И при этом вам выгодно гонять сборщик мусор как нужно и легко.  возможному переполнению переполнению то ну как бы будет невозможно то есть когда память заполняется то вы сборщик мусора вынуждены прогнать все таки да вот этим не менее есть такой такая идея что если сборно чтобы гонять сборщик мусор мусора реже вам надо много памяти и вот тут я думаю вы замечали что java действительно джавовские программы вообще большинство программ  на языках с управляемой памятью, они, в общем-то, очень любят память. Ну и вот самое обидное, что любят они именно с целью хранить там мусор. Тем не менее, на самом деле, светлая сторона, которая у меня тут на слайде упоминается, ну вот опять же, я не знаю, у вас как бы нет опыта достаточного описания на плюсах,  Но вообще, скажем так, плюсы Java, их сравнить по фичам, они, в общем-то, более-менее похожи. Но VC++ это язык со сборкой мусора, без сборки мусора, точнее, там есть всякие элементы, типа, так называемых, смартфейтеров, которые, в общем-то, покрывают далеко не все, что оно делает.  Но, тем не менее, на C++ у вас явная локация. На Java у вас управляемая память. Что это выливается? Выливается обычно оценка, что стоимость закупки на Java от 3 до 5 раз дешевле, чем на C++ в человека часах. То есть в среднем программист на C++ он от 3-4 до 2-3 времени  И на самом деле, опять же, по-моему, вам вопрос уже будет искать. Точнее сказать, мы же макушкой закроемся, потому что...  не поможет, то откроем. Так вот, то есть и эффект этого довольно сильный, она просто состоит в том, что если у вас, персонально у вас эта разница три раза, а не пять, то вы можете прийти к работодателю, и вы можете это доказать. Вы можете прийти к работодателю, ну и, конечно, на 20% вам зарплату не получится, но, по крайней мере, что-то старговать лишнего с работодателем вы сможете.  чтобы у вас от коэффициент был тренинг пять раз, вам надо как раз делать то, чего я вас постоянно убеждаю, а именно, думаю, голодой. Без этого у вас ничего не получится. Но, тем не менее, на этой кримистической ноте сборщики мусора... А, на чем я остановился, что сборщики мусора, как бы, достигаются это не бесплатно. Достигается это за счет, как я уже говорил, любви к оперативной памяти, памяти, как я уже говорил, это дорого.  А самое интересное, что Власов сейчас возлюбил, Александр Александрович возлюбил такое забавное утверждение, которое, в общем-то, тоже верное. Что очень большая часть прогрессов Итаки, она на самом деле, это прогресс оборудования. И, в частности, сборка мусора Маркинсвит, она была известна буквально с 50-х годов прошлого столетия. Но экономически применима в массовом масштабе, она  среднего пользователя смогла себе позволить каждому поставить на рабочий стол компьютер с несколькими десятками мегабайт оперативной памяти. Только тогда джава и смогла промышленно применяться. Ну точнее не джава, а другие языки с маркенсив сборкой мусора. И тем не менее думать как этот маркенсив улучшить. Народ начал давно тоже и некоторые идеи у нас как бы тоже  возникают то есть вот первая идея то есть с самого начала java у нее была такая забавная фишка под названием не блокирующийся сборщик мусора на самом деле то как она у меня тут написана в общем то она немножко не так выглядит как я сейчас описываю по этой картинке но тем не менее идея примерно такая что мы на каждый объект ставим  Защиту от записи. Точнее как, мы ее ставим функционально и ставим знак этой защиты от записи в момент, когда мы в него ставим метку. Соответственно, если нить с объектом работает только на чтение, то ее останавливать не надо, и остановка мира как таковая не нужна.  Потом мы помещаем все объекты, но нити, которые пытаются модифицировать уже помещенные объекты, вот их там выловим и тормозим. То есть на самом деле это не совсем то, что у меня тут нарисовано на картинке. Тут как бы забавный более подход, когда всякими фибристиками эти пометки делаются, и потом на конечном этапе все-таки делается ремарк, то есть то, что мы пропустили.  скажем так, могли пропустить в ходе параллельной сборки. Тем не менее, вот эта идея, она как бы, ну, во-первых, тут тоже есть некое читерство, то есть понятно, что мы как бы не полностью избегаем остановки мира. То есть нити все-таки останавливаются, и в лучшем случае они тоже могут остановиться все. Второй момент, что это далеко не бесплатно, потому что если у нас стоят эти барьеры,  Нам их надо проверять все время, при каждой модификации объекта. То есть за вас это делает Java Runtime, но на самом деле, как мы дальше увидим, во втором семестре примитива синхронизации это очень дорого, на самом деле, по времени исполнения. И поэтому такой вот неблокирующийся сборщик, он избегает пауз, но он сажает производительность.  Вот, а тем не менее, и поэтому, кстати, в джаве он по умолчанию выключил. Вот, тем не менее, такая идея есть. Немножко более интересная идея, на самом деле в джаве, в современной, сделана еще более интересная идея, которая, ну, сейчас я проэтапно объясню. Первая идея, на самом деле, вы с ней тоже не сталкивались, но реально в таком виде она используется в хаскере.  В Хаскеле так называемый копирующий или иногда называемый генерационным сборщиком мусора. То есть идея примерно такая, что мы всю кучу делим на два одинаковых половины. И сначала мы выделяем все объекты в одном половине. Выделяем и никакой сборки не проводим. Просто выделяем, выделяем, выделяем.  Кстати, на самом деле уже на этом есть экономия сильная, что мы, по сути, у нас никакой фрагментации не происходит. То есть объекты выделяются, и в какой-то момент это окончается. Так, интересно сказать.  попробую потише. Потом половина кучи кончилась. Мы начинаем сборку мусора. На этапе сборки мусора мы одновременно с маркфазой переносим объект во вторую половину. При этом, кстати, делается интересная деталь. Видите, тут нарисованы стрелочки. На самом деле старый объект остается на старом месте.  получает указатель на свою копию нового. То есть, дальше происходит что? То есть, когда мы приходим еще раз на уже перенесенный альф, мы приходим на него, естественно, по старой ссылке. И мы можем увидеть, куда его перенесли и прооткредить ссылку. Кстати, у меня тут в книжке ошибка. То есть, у меня утверждается, что для того, чтобы такое сделать, надо, чтобы у вас  На самом деле, если мы делаем марк-н-свип, то можно обойтись без этого. То есть можно обновлять все ссылки. При марк-н-свипе мы просматриваем все живые ссылки. Значит, мы их можем апдейтить. Мы, кстати, Java, по крайней мере, как мне сообщили разработчики JVM, непосредственно она работает именно так. То есть она апдейтит просто все ссылки по мере того, как их находят.  То есть, на самом деле, мы вот, второй момент, дальше, когда мы все объекты перенесли, то мы просто все, что осталось, объявляем мусором, и, опять же, на этом все кончается. То есть, на самом деле, мы на этом имеем два, хотя мы вроде бы делаем лишнюю работу по копированию объектов, но мы на этом имеем два больших профита. Первый профит, я уже сказал, что у нас аллокация происходит очень быстро.  свободной, занятой памяти в этой куче и выделяем за константные, очень короткое время. Второй профит, который мы имеем, что каждая сборка мусора это дефрагментация. То есть такая штука, как я уже говорил, она совмещает сборку мусора с дефрагментацией, и это уж хорошо. Тем не менее, в Java последний год  Вот, в Java пошли еще дальше и, так сказать, уже в Java 1.3 сделали такую... Ну, во-первых, они... Так, ой, блин, я пока успеваю подъехать, они уж перестают все лить. Так, интересно, я смогу уже наставить? Не, не слабо. Ладно, итак, то есть тут первые, в общем-то...  На самом деле, действительно очень много идей, которые я сам применил к джаве, они их почерпнули из наблюдения за тем, как реально себя ведут джаванские программы. Ну и вот первая идея, на самом деле, копирующие сборщики мусора, эта идея тоже довольно старая, хотя тоже понятно, что, так сказать,  она довольно дорогая по ресурсам, поэтому она тоже довольно поздно, так сказать, стала экономически возможной. Тем не менее, идея, которую тут я пытаюсь развивать, она состоит в том, что, как бы, объекты, в принципе, нужно поделить на так называемые долгоживущие-краткоживущие. То есть, краткоживущие объекты, они, в общем-то, так сказать, в силу  Они составляют большую часть объектов и большую часть мунистра. Во-вторых, такой еще забавный факт, что коротко живущие объекты, скажем так, долго живущие объекты на них ссылаются редко. В обратную сторону бывает. А вообще старшее поколение на младше ссылается редко. Мы вот обе эти идеи, они позволили сделать интересную схему  которая в джаве до сих пор используется по умолчанию. Так, соответственно, джавовский, так называемый, ходспот-генерационный сборщик мусора, он построен вокруг вот этого фактика.  И на самом деле выглядит он немножко странно. То есть куча делится на четыре региона. Причем у меня тут соотношение, которое используется в так называемой серверной редакции Java, когда старшее поколение примерно соответствует остальным трём регионам совокупности. Почему это серверное? Сейчас объясню.  Тем не менее, вот у меня есть как бы ссылка на официальное описание этой штуки. Вот, то есть, на самом деле, видите, статья 2002 года, тем не менее, в общем-то, эта конструкция не сильно изменилась с тех пор. То есть, вот, ну, старшее поколение, мы сейчас про него позже поговорим. Наверное, пойдем справа налево. То есть, первое, это так называемый Эдем. Опять же, библейские ассоциации, надо объяснять или нет. Вот.  То есть вот этот самый Эдем, там создаются все новые объекты. Создаются они по принципу того же самого Ватермарка, то есть просто следится граница занятого свободной памяти. И они создаются быстро, и они тоже никак не чистятся. Создаются никак не чистятся, потом в какой-то момент Эдем кончается. Начинается так называемая маленькая сборка мусора. Малая сборка мусора.  Минор коллекшн. То есть на Минор коллекшн у нас происходит штука. На первой сборке мусора у нас все остальные регионы свободны. Соответственно, мы все живые объекты из Адема копируем в так называемый Survivor Space 1. И Адем очищаем, и дальше начинаем создавать в нем новые объекты.  Кстати, обратите внимание, что оно тут нарисовано в масштабе, то есть тут уже зашито жесткое предположение, что большинство объектов Эдема малой сборки не переживет. Просто на уровне размеров этой памяти. Потом на второй малой сборке у нас происходят более интересные конструкции. У нас есть уже живые объекты в Survivor Space 1 и в Эдеме. И мы их все копируем в Survivor Space 2.  Вот и так вот их переставляем, переставляем, переставляем. Ну и вот в какой-то момент у нас эти сервайверс-плюсы начинают заполняться. Ну и вот тут начинается самое интересное. Самое интересное состоит в том, что мы, как бы вот тут уже у нас нет четкой отдельной фразы, но мы на каждом объекте еще видим счетчик, сколько малых сборок мусора он пережил.  И соответственно, когда нам кажется, что Survivor Spaces начинают заполняться, ну и объекты из Survivor Spaces, самые старые объекты, в Survivor Spaces начинаем переселять старые поколения. И на самом деле, вот тут дальше как раз начинается веселуха. Потому что клиентская Java, она...  гигантский, и считается, что мы его выбираем таким большим, чтобы сборки мусора в старом поколении дело вообще не доходило. Хотя, если у вас клиентское приложение, какая-нибудь там, Eclipse какой-нибудь, или что там еще сейчас на джаве написано, работает долго, то у вас может происходить сборка старого поколения.  Тем не менее, когда мы делаем сборку, когда серверная Java, то считается, что приложение будет в любом случае работать долгое, но тем не менее старое поколение там как бы оно фрегментированное, это обычная фрегментированная ручка. То есть там сборка мусора происходит обычным образом. Вот мы вот, так сказать, картинка, как выглядит управление памятью в Java.  такая характерная пила то есть вот если вы посмотрите на объем занятой памяти в каком-нибудь среде исполнения с обычным маркенсвипом например в гугле в C-sharp то вы увидите такую ровную пилообразную картинку то есть объекты растут растут растут прошла сбухка растут прошла сбухка здесь мы видим такую рекурсивную пилу то есть идет  Сначала у нас старшее поколение заполняется, и у нас большой сборки не происходит. Потом происходит большая сборка, мы убираем мусор из старшего поколения. Потом, по мере заполнения старшего поколения, эти большие сборки начинают происходить чаще. Тем не менее, эти маленькие сборки происходят быстро. Они, как я уже говорил,  уничтожая большую часть муцера. И, в общем-то, runtime поэтому работает быстрее. И, в общем-то, уже когда они эту штуку ввели, в общем-то, как раз тогда сам уже хвастался, что у них в Java, так сказать, проигрыш в производительности к плюсам, он уже стал измеряться какими-то отдельными процентами. То есть, на самом деле, реально у Java есть, конечно, такая забавная фаза прогрева.  То есть, пока она еще не откомпилировала весь байт-код реально используемый, тогда она работает медленно. Потом она прогревается, все компилирует и начинает работать быстро. Но, тем не менее, пока не сделали вот этот hotspot сборщик, примерно 20% джава съедала на сбух мусора. Введение вот этой конструкции позволило процент, входящий на сбух мусора, сильно уменьшить.  стоимость сборки мусора и, в общем-то, на многих задачах Java стала C++ сопоставима. Особенно в те времена, это было видно, когда C++-овцы улетелись Standard Template Library. Я вам, по-моему, про это рассказывал, что неумеренное, так сказать, пользование STL-ом, оно тоже приводит к тому, что у вас делается очень много малоков, куча сильно фрагментируется,  у вас получается приложение, которое большую часть времени проводит в Маллоке, и при этом из-за фрагментации куча очень любит память. И вот, скажем, версии офиса, браузеров, сделанных в нулевые годы, они были именно такие. Потом-то мы немножко научились пользоваться STL, и стало немножко получше. На самом деле еще одна тема, которую, так сказать, надо объяснить,  То есть, опять же, если у вас есть объекты старого поколения, то по-хорошему, даже при малой сборке мусора, их надо просматривать все. Ну, чтобы, так сказать, не предписать, так сказать, не потерять объекты. Ну, видите, мы же, в общем-то, в старшее поколение переносим простым аутистическим алгоритмам. Утверждение, что старые долгоживущие объекты не ссылаются на короткоживущие,  Оно само по себе тоже чисто статистическое. То есть, в общем-то, вы всегда можете найти примеры объектов, которые все-таки делают. Вот. То есть, соответственно, если такие объекты у нас есть, ибо мы, старшее поколение, должны просматривать все. И даже если мы при этом не собираем мусор, мы его должны просматривать, откуда получается экономия. Вроде бы неоткуда и получится. Да?  Ей не откуда получится, но она получается. Почему? Потому что вводится еще одно забавное понятие, которое называется ременгриоцит. Ременгриоцит – это таблица указателей из объектов старого поколения в младшие три. То есть вот сурвайверские среды, они в свою руку называются младшим поколением.  утверждаем, что таких ссылок мало, но они есть, поэтому Remembered set не должен быть большим. И вот этот Remembered set носит ссылок и вместо того, чтобы его перестраивать при сборке мусора, его просто используют как есть, в качестве ее добавления к списку храневых объектов. То есть все объекты, которые там упоминаются, они  они короче считаются живыми. Даже если на самом деле они не живые, и кто на них ссылался, он уже давно его как бы надо парить. Тем не менее, этот ремейнгриоцент, как раз за счет него малые сборки делаются дешевыми. Поэтому это изобретение, оно такое немножко сомнительное, то есть, опять же, нужно написать  Но это надо писать нарушно. И, в общем, вот. Тем не менее, вот такая штука. Ну и вот тут мы вылезаем на одну интересную тему. Уже вылезаем на этой конструкции. На самом деле мы получаем такой забавный фактик, который вы, по-моему, в Java, значимость которого еще не проходили, вы уже учились в Java с файлами работы.  Некоторые начали работать. Ну и вот, на самом деле, вас ведь, наверное, даже должны были учить целому синтезу. То есть увидели, что объект файл в Java, его надо закрывать. Был момент. И вообще-то в современной Java есть даже специальный синтезис, который позволяет гарантировать, что вы этот объект закроете.  и на выходе из этого блока объект покарантирован на звук hold. Что, кстати, интересно, потому что если вы вынесете из этого объекта ссылку на файл, на объект файла, она превратится в сборщик мусор и объект файл не соберет. На самом деле это, кстати, такой довольно философский момент, который тоже очень важно понимать.  На самом деле, с одной стороны сборка мусора это хорошо, с другой стороны, когда вы пытаетесь стыковать разные стратегии сборки мусора, или сборку мусора с неуправляемой банитью, вот тут-то вас ждут настоящие приключения. Потому что, с одной стороны, ну вот опять же самая типовая ситуация,  Это если вы, так сказать, на объект сохранили ссылку, но не сказали ронтайму, не сказали вербочек коллектору, что у вас эта ссылка есть, да? Сборщик Мусы эту ссылку радостно соберут, точнее объект по ссылке. У вас опять получится всякий указатель, да? Причем он получится по закону худлости и самым ежедневным для вас моментом. Вот это первое дело.  Второй вариант, который наиболее очевиден с запретыми файлами, он немножко хуже. То есть если вы, например, закрываете файл только в финализаторе объекта, вы финализатору объектов проходили? Нет. Ну, кстати, может быть и правильно, но тем не менее в Java есть аналог деструктора, то есть метод, который называется финализатор, который зовется, когда объект собирается звучать.  И, на самом деле, то, что вас ему не учили, в этом есть некоторая правда. Потому что, на самом деле, первый момент, даже из того, как работает код спут, нужно понять, что есть мусор, до которого сбросчик мусора не дойдет никогда. Или может не доходить очень долго. И если у вас в таком объекте сидит открытый файл, то он так и останется незакрытым.  Ну или это может быть не файл, например,  что вы в директорсе объекты обязаны удалять явно объекты, которые существуют в мозгах видеоадаптера. Вы их обязаны удалять явно, а если вы удаляете только когда до них дойдет гербоч коллектор, этого может не произойти никогда. У вас видео память кончится. И это все очень весело. И на самом деле, вот тут, пожалуй, единственная мораль, которую я могу рассказать,  Что, с одной стороны, да, Java, она как бы освобождает, ну, так сказать, удешевляет разработку. Но если вы не думаете, каков срок жизни ваших объектов, и когда и почему они уничтожаются, у вас будут баги. Все плюсы в Java будут разные баги. И у них может быть разная стоимость нахождения.  И, на самом деле, что еще я хотел на эту тему сказать? На тему багов и финализаторов и всего прочего. А, на самом деле, насчет удешевления разработки, и, кстати, насчет искусственного интеллекта. Ну вот, как раз, это был один забавный поворотный момент.  То есть, действительно, массовая стоимость разработки программного обеспечения резко понизилась. Казалось бы, эффект обычно пугает эффектом, что, так сказать, программисты останутся без работы. На самом деле, когда в 90-е годы это произошло, эффект оказался совсем обратным.  Поэтому, так сказать, количество вакансий для программистов только увеличилось. Кстати, на самом деле, вот тут как раз в краткосрочной перспективе, опять же, все, наверное, слышали, что и я вам даже про это говорил, что сейчас в джунирах программистов спрос резко упал. Тем не менее, и некоторое это связано с искусственным интеллектом.  На самом деле, с одной стороны, действительно тот искусственный интеллект, который мы видим, это явно не окончательное состояние этой технологии, потому что даже то, что мы видим, оно быстро революции не хватит. С другой стороны, опять-таки, то, что мы видим, что этот искусственный интеллект, главная опасность его, что он порождает  порождает опять-таки мусор. То есть, что одна компания шлёт порождённый искусственным интеллектом коммерческие предложения, другая компания на них шлёт порождённый искусственным интеллектом ответы. То есть, начинает циркулировать какой-то очень-то бессмысленный текст. Ну и, на самом деле, одна, какие-то сингулярности, это, опять-таки, тоже ездившая по Китаю,  Они рассказывают, что есть всяких обслуживающих персоналов, которые, как это тоже в одном советском фильме, было женщину вынули, автомат засунули, да? То есть она с тобой не разговаривает, она тебе ставит коробочку, и эта коробочка что-то говорит, ну синтезирована, естественно.  тем не менее, вот это какая-то перспектива. Другая перспектива та, что все-таки если писать фонд, то есть если писать его автоматически, то то уже как бы уже ваканси, скажем так, для семейных девелоперов на исправление результатов вейпудинга, уже так прямо в объявлениях ваканси пишут. Во-вторых, ну опять же фонд инжиниринг, чтобы  Этим тоже надо заниматься.  И, опять же, тем программистам, которые будут это использовать, будет повышенное тренивание, опять же, к умению соображать, что они делают. Поэтому, так сказать, если вы умеете соображать, что делаете, то вас ждет, может быть, не гарантированно, но, так сказать, какие-то светлые перспективы. А если не умеете, ну, вот тут как бы есть повод сказать,  Тем не менее, на чем мы остановились, на том, что вот джавовский подсборщик мусора, это до сих пор то, что идет в джаве по умолчанию. Тем не менее, опять же, если вы на джаве настолько серьезно писали, или хотя бы читали документацию по джаве, то вы видели там такую опцию, есть такой еще один сборщик, дживан. Да? Градин.  Мы не видели это плохо, а тем не менее сборщик G1, он тоже уже примерно вам ровесник, то есть он появился где-то в начале десятых. Ну, по крайней мере, анонсы его пошли. И G1 сборщик мусора, он на самом деле G1, он расшифровывается как garbage first. То есть цель G1 сборщика,  она состояла, опять же, в том, чтобы уменьшить продолжительность пауз с остановкой мира. Потому что, как мы помним, вот эта вот большая сборка, она остановку мира все-таки требует. И избавиться от этого понятия. Ну и как ее избавиться? То есть вместо вот этих фиксированных поколений кучу разбивают на так называемые карты  примерно одинакового размера, размером около нескольких мегабайт. Маленькие регионы, которых очень много. При этом, на самом деле, между ними есть тоже, опять-таки, в некоторых формах документы, деление между этими картами описывают тоже как поколение. Но это деление динамическое. То есть регион постоянно становится по младшим поколениям, по старшим.  Ну и вот дальше второй веселый элемент, что между регионами, у каждого региона есть Remember Reset свой, который содержит ссылки внутрь этого региона из других регионов. Вот, то есть, опять-таки, в ходспоте Remember Reset один, поэтому его нужно рассматривать и как ссылки из старшего поколения,  И как ссылки в младшее поколение, да? Тут у нас старших поколений много, и тут у нас становится очевидно, что ременгрицет это ссылки снаружи, внутрь этого региона. Что это нам дает? Ну, во-первых, действительно начинаем с того, что мы, когда у нас куча вся пустая, мы начинаем создавать объекты, мы просто берем какой-то регион, объявляем его Эдемом, и создаем там объекты.  Он кончается. Мы просто оставляем все как есть, берем новый регион, поскольку он под порядком мегабайт, он маленький, поэтому он кончается очень быстро. Мы берем второй регион, тоже его заполняем, заполняем, заполняем. Вот, заполняем, и дальше мы глядим на элементы рецепты и отслеживаем их состояние,  И, соответственно, когда живых объектов там становится мало, причем это на самом деле не особо зависит от заполненности остальной кучи, то есть когда мы видим регион, в котором нам кажется, что мало живых объектов, мы делаем так называемую эвакуацию. То есть мы точно подсчитываем, сколько объектов там на самом деле живые, и их переносим в какой-то текущей адрес.  А регион, который, так сказать, эвакуировали, мы объявляем полностью свободным. Ну и вот, с одной стороны, действительно, у нас появляется очень много малых сборок мусора, и никогда не происходит ничего похожего на большую сборку мусора. Это первое. Второе, что происходит, что паузы на эту малую сборку, они действительно всегда очень маленькие, потому что сами региончики очень маленькие.  Хотя, на самом деле, на этапе точной сборки, точного подсчета, что именно мусор, там все-таки стоп-возд происходит, но он очень короткий. Тем не менее, это постоянное отслеживание, сколько где мусора, оно делается фоновой нитью. И, по сути, G1 занимает под себя целиком одну процессорную диапону.  То есть он оправдан только в конфигурациях, для которых, правда, очень много процессорных ягер. Он его занимает целиком. И, в общем-то, он некую просадку производительности все остальные джабы дает. Потому что тоже надо постоянно, так сказать, с ним синхронизоваться. Поэтому он как бы тоже не бесплатный. И поэтому по умолчанию он не включается. И оправдан он только у серверных приложений.  Но, тем не менее, он, так сказать, для серверных приложений, которое действительно было бы очень неприятно, если бы каждая, там, допустим, сколько-то секунд задумывалась, как это делает HotSpot. Это, наверное, не очень хорошо. Поэтому G1, ну, в общем-то, так сказать, мы пока что, ну, на самом деле, отчасти, тоже один из моих любимых набросов, что ведь, опять же, вы тоже этот момент не захватили.  Но ведь изначально была такая компания Sun, которая делала Java. Потом Моракл купил Sun вместе с большой линейкой опенсорсных продуктов. Некоторые из этих опенсорсных продуктов, например, либо Офис, либо ЭДБ, от них, так сказать, открыто сбежали. Тем не менее, есть вот такой замечательный наброс, что почему?  Но он его, кстати, правда не придушил, потому что он продолжает развиваться. Но, тем не менее, почему Рэкл не придушил виртулбекс? Потому что не виртулбекс. Тогда, на самом деле, наоборот, он немножко лучше.  5 штук вы этого сделал с джавой, и я, так сказать, вам оставляю на тему задуматься. Но, тем не менее, на этой эргемистической ноте давайте сделаем